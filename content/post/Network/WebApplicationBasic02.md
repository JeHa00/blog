---
title: "[TIL]Web Application Basic study: 1,2,3 계층"
date: 2022-08-30T18:50:58+09:00
draft: false
summary: OSI 7 layer는 전체적으로 무슨 층으로 구성되어 있고, 1 계층인 물리계층, 2 계층인 데이터링크 계층, 3 계층인 네트워크 계층에 대해 알아본다.  
tags: ["TIL", "Network"]
categories: ["Network"]
---
# 0. Introduction: 웹 애플리케이션 기초

### 학습 목적

> **_기반 지식을 다지기_**

사용자가 눈에 보이는 부분을 개발하는 부분을 **프론트엔드** , 사용자 눈에 보이지 않는 부분을 개발하는 부분을 **백엔드** 라 한다.

프론트엔드는 코드 실행 결과를 눈으로 직접 바로바로 확인이 가능하다.  

하지만, **백엔드는 코드의 결과를 눈으로 확인하기 어렵다. 그래서 오류의 원인을 찾는 디버깅이 어렵다**.

**이 디버깅을 하기 위해서는 기반지식이 필요하다.** 입문자가 생각하는 개발은 코드라고 생각하지만, **실제 개발에 필요한 내용은 기반지식이다.**

그래서 이번에 기반 지식 아래 내용을 학습해본다.

- 클라이언트 - 서버 구조
- 웹 서버 구조 설계
- 네트워크

&nbsp;

---

# 3. 네트워크 기초

서로 다른 컴퓨터 회사들의 컴퓨터들이 자유롭게 통신할 수 있도록, 그리고 네트워크 통신 중 어느 부분에서 문제가 발생했는지를 알 수 있도록 ISO(International Organization for Standardization, 국제표준화기구)에서 OSI 모델이라는 표준 규격을 만들었다.  이 모델이 바로 OSI 7 계층이다.  

### OSI 7 layer

OSI 7 layer의 구성은 다음과 같다. 그리고, 이 **OSI 7 layer** 를 4개의 계층으로 단순화하여 표현한 것을 **TCP/IP 4 layer** 라 한다. 설명은 OSI 7 layer를 기준으로 한다.

그리고, 각 계층마다 통신하기 위해 사용되는 형식, 약속, 규약들이 존재하는데 이를 **Protocol(프로토콜)** 이라 한다.  

| OSI 7 layer | TCP/IP 4 layer | 사용되는 프로토콜 | 설명 | PDU(Protocol Data Unit) | 주요 네트워크 기기 |
| ---- | ---- | ---- | ---- | ---- | ---- |
|응용 계층| 4. 응용 계층| HTTP, FTP, SMTP, DNS | 애플리케이션 서비스 제공 | 메시지 혹은 데이터 | - |
|표현 계층| 4. 응용 계층| HTTP, FTP, SMTP, DNS | 문자코드, 압축, 암호화 방식으로 데이터 변환 | 메시지 혹은 데이터  | -  |
|세션 계층| 4. 응용 계층| HTTP, FTP, SMTP, DNS | 세션 연결/설정/해제와 통신 방식 결정 | 메시지 혹은 데이터  | - |
|전송 계층| 3. 전송 계층|TCP, UDP | 신뢰성 있는 통신 구현 | segment | - |
|네트워크 계층| 2. 인터넷 계층 | IP | 한 네트워크에서 다른 네트워크와 통신하기 위한 IP 주소 결정 | packet | 라우터 |
|데이터링크 계층| 1. 네트워크 인터페이스 계층 | 이더넷 | '네트워크 기기' 간의 데이터 전송과 물리 주소 결정 | frame | 스위치 |
|물리 계층| 1. 네트워크 인터페이스 계층 | RS-232, RS-449 | 물리적 연결과 데이터를 전기 신호로 변환 | | 리피터, 허브 |

![image](https://t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/axm/image/lEbuexy5CZ5WK6Xq5yZuwg_8tR4.png)

위 각 계층에 대한 설명에 추가 설명  

- 1계층 ~ 2계층: 한 네트워크 내에서 데이터를 주고 받는 과정
- 3계층부터는 네트워크 간 데이터를 주고 받는 과정  
- 3계층: 여러 네트워크 간 데이터 전송을 위해 타 네트워크 주소 결정
- 4계층: 3계층에서 데이터가 유실되거나 더 정확하게 데이터를 전송하기 위한 정보 추가  
- 5 ~ 7 계층: 특정 애플리케이션까지 도달하기 위한 데이터 정보 추가  

### 송신 및 수신 순서

- 송신할 때 순서: 하위 계층으로 보내는 과정
  - 응용 계층 -> 표현 계층 -> 세션 계층 -> 전송 계층 -> 네트워크 계층 -> 데이터링크 계층 -> 물리 계층

- 수신할 때 순서는 송신 순서의 역방향으로 진행된다. (상위 계층으로 보내는 과정)

### 헤더(Header), 캡슐화(Encapsulation) 그리고 역캡슐화(Decapsulation)

![image](https://user-images.githubusercontent.com/78094972/236663376-e5648e74-186b-4fbe-b305-3ae6c6d0a48f.png)

- from: [예술하는 개발자 - 캡슐화, 역캡슐화, PDU](https://www.youtube.com/watch?v=rBw_e7zQLMQ)  

우리가 현실세계에서 우편을 보낼 때 보낼 물건을 바로 보내는 게 아니라 우편 봉투에 넣고 주소 태그를 붙이는 것처럼 소프트웨어 세계에서도 데이터가 각 계층을 통해 보내질 때, 계층을 한 번 이동할 때마다 각 계층에 해당되는  **header(헤더)** 가 붙여진다. 이 헤더에는 목적지 정보, 출발지 정보, 에러 체크 등 필요한 정보들이 담겨져 있다.

이 헤더는 전송되는 원본 데이터 앞에 추가적으로 붙는다.  

이렇게 송신 과정에서 데이터 앞에 헤더를 붙이는 것을 **Encapsulation(캡슐화)** 라고 한다.

그리고 이와 반대로 헤더를 제거하는 것을 **Decapsulation(역캡슐화)** 라고 한다.

캡슐화는 송신 과정에서 각 계층을 통과할 때마다 각 계층마다 일어나며, 역캡슐화는 수신 과정에서 각 계층을 통과할 때마다 각 계층마다 일어난다.  

&nbsp;

## 3.1 1계층: 물리계층

- 데이터를 0과 1로 구성된 데이터로 바꾼 후, 이를 전기신호로 바꿔서 보낸다. 그리고, 수신할 때는 이 전기신호를 0과 1로 바꾸고, 이를 다시 데이터로 바꾸는 계층이다.  

- 물리계층에서는 물리 장치인 랜선과 랜카드가 필요하다.

&nbsp;

### LAN card

- 0과 1로 구성된 데이터를 전기 신호로 바꾸는 역할

### 1계층 장비: 허브(Hub)

- 이 허브에 여러 개의 포트가 있고, 이 허브를 통해 다른 컴퓨터로 전송한다.

- ❗️ 단점: 이 허브는 받는 상대를 지정할 수 없다. 허브의 포트에 연결된 모든 컴퓨터에게 보내진다.  
  - Why? 1계층에는 지정된 header가 없기 때문이다.  
  - 이러한 단점을 극복할수록 위 계층으로 올라간다고 생각하자.  

&nbsp;

## 3.2 2계층: 데이터링크 계층

> **_Data Link Layer로, 네트워크 장비 사이의 신호를 주고 받는 '규칙을 정하는' 층으로서, 스위치라는 장비를 이용해 스위치에 연결되어 있는 컴퓨터들이 이더넷이라는 규칙하에 프레임을 주고 받는다._**

### 이더넷(ethernet)

> **_랜(LAN, Local Area Network)에 적용되는 규칙으로, 랜선을 꽂을 때 여러 선들이 있는데 이 선들에 대한 규칙을 말한다._**

- 스위치와 같은 장비를 이용해 데이터를 주고 받을 때 사용하는 규칙  

&nbsp;

### 맥 주소(Mac Address)

> **_LAN 카드에는 맥 주소(48비트)가 할당되어 있다._**

- 맥 주소 = 랜카드 제조사 번호(앞 부분) + 랜카드 제조사가 랜카드에 할당한 번호(뒷 부분)

- 맥 주소를 알면 그 PC의 위치를 알 수 있다.  

- 16진수로 표현되어있다.
  - 숫자 1개당 이진수를 보면 4bit로 표현한 것을 알 수 있다. 즉, 48bit는 12개의 문자를 의미한다.

&nbsp;

### frame(프레임)

- 프레임(frame) = 이더넷 헤더 + 데이터 + FCS
  - FCS = Frame Check Sequence의 약어로, 데이터 전송 중 오류가 발생하는지 확인하는 용도  

- 이더넷 헤더 = 목적지 MAC 주소 + 출발지 MAC 주소 + 유형
  - 목적지 MAC 주소: 6 byte
  - 출발지 MAC 주소: 6 byte
  - 유형: 2 byte ex) IPv4, IPv6, ARP  

&nbsp;

### header(헤더)

> **_전송되는 데이터의 맨 앞에 위치하는 추가적인 정보 데이터를 의미하는데, 데이터의 내용과 성격을 식별 또는 제어하는데 사용_**

&nbsp;

---

### 2계층 장비: 스위치(switch)

> **_허브의 단점을 보완한 것_**

- 스위치라는 장비를 이용해 스위치에 연결되어 있는 컴퓨터들이 이더넷이라는 규칙하에 프레임을 주고 받는다.
- 이 방법으로는 **동일한 스위치에 연결되어 있는 컴퓨터들끼리만** 데이터를 주고받을 수 있다.

  - 스위치에는 여러 포트를 가지고 있는데, 각 포트마다 host가 연결되어 있어서, 각 포트마다 다른 맥 주소를 가진다.  
  - 그래서 데이터를 보낼 때 맥 주소가 있는지 체크하여 존재하면 바로 보낼 수 있고, 없으면 플러딩을 한다.  

🔆 스위치에 연결된 컴퓨터가 연결된 다른 컴퓨터에게 보낼려고하는데 MAC address가 없을 경우에는 switch에 연결된 모든 컴퓨터에게 보낸다. 이를 **_플러딩(Flooding)_** 이라 한다.

- 그러면 스위치 밖에 있는 컴퓨터와는 어떻게 데이터를 주고 받을까?

&nbsp;

---

## 3.3 3계층: 네트워크 계층

> **_굉장히 중요한 계층으로, 3계층 장비인 라우터에 스위치에 연결되어 있어서 각 스위치로 전달한다._**

- **네트워크란? 하나의 스위치에 연결되어 있는 컴퓨터의 모음** 인데, 그러면 서로 다른 네트워크에 있는 컴퓨터들은 어떻게 데이터를 주고 받을까???

- 네트워크 계층에서는 라우터라는 장비를 사용한다.

- 이 라우터라는 장비는 2계층의 스위치와 1계층의 허브 기능을 모두 포함한다. 요즘은 스위치와 라우터를 혼용해서 언급하기도 한다.  

&nbsp;

### 각 계층에서의 장비, 주소, 비트

|계층 사용 장비 | 주소 | 비트, 진수|
|----|----|----|
|1계층: 허브사용 |||
|2계층: 스위치 사용| MAC 주소를 사용 | 48비트, 16진수|
|3계층: 라우터 사용 | IP 주소를 사용 | 32비트, 10진수|

- 네트워크 계층에서도 header를 붙히는데 IP 헤더라고 부른다.  

- 그리고 3계층에서 헤더와 데이터를 합친 단위를 **_IP packet_** 이라 한다.  
  - IP packet = IP header + data
  - 이 IP header에는 많은 정보들이 담겨있다.  

- IP address = Network ID + Host ID
  - Network ID : 자신이 속한 네트워크  
  - Host ID: 해당 네트워크에 속한 특정 컴퓨터  

&nbsp;

### IP 주소 형식

- IP 수가 부족해서 IPv6를 만들었다.  

| | IPv4 | IPv6 |
| ---- |---- |---- |
| 주소 형식 | 127.0.0.1 | FE80:CD00:0000:0CDE:1257:0000:211E:729C |
| 주소 표현 | 10진수 | 16진수 |
| 크기 | 32비트 | 128비트 |
| 최대 표현 개수 | 4.29 x 10^(9) | 3.4 x 10^(38) |

&nbsp;

### 공인(public) IP 와 사설(private) IP

- 공인 IP: 인터넷 전체에서 유일한 주소. ex) 대한민국 서울시 강남구 OO동 OO아파트
- 사설 IP: 네트워크 상에서 유일한 주소. ex) 101동 101호  

- 그래서 다른 분께 IP 주소를 언급할 때 공인 IP를 말해야 한다. 사설만으로는 알 수 없다.  

❗️ 공인 IP가 써야되는 곳에 사설 IP 주소를 쓰면 안되므로, 먼저 서버를 구축하기 전에 학습한다.

&nbsp;

### 네트워크 ID class

- IP 주소는 네트워크 ID와 호스트 ID로 구성되었는데, 네트워크의 크기에 따라서 더 분류된다.

- **A class: 대규모 네트워크**
  - 00000001 00000000 00000000 00000000
  - 프리픽스 8자리: 네트워크 ID / 나머지: 호스트 ID

- **B class: 중간 규모 네트워크**
  - 00000001 00000000 00000000 00000000
  - 프리픽스 16자리: 네트워크 ID / 나머지: 호스트 ID
  - docker에서 만드는 컨테이너의 IP 주소를 보면 B class임을 알 수 있다.  

- **C class: 소규모 네트워크**
  - 10000000 00000000 00000000 00000000
  - 프리픽스 24자리: 네트워크 ID / 나머지: 호스트 ID

| 클래스 | A class | B class | C class |
|---- | ----| ---- | ---- |
| 공인 IP 주소 범위 | 1.0.0.0 ~ 9.255.255.255, 11.0.0.0 ~ 126.255.255.255 | 128.0.0.0 ~ 172.15.255.255, 172.32.0.0 ~ 191.255.255.255 | 192.0.0.0 ~ 192.167.255.255, 192.169.0.0 ~ 223.255.255.255 |
| 사설 IP 주소 범위 |10.0.0.0 ~ 10.255.255.255.255 | 172.16.0.0 ~ 172.31.255.255 | 192.168.0.0 ~ 192.168.255.255 |
| 프리 픽스 | 8자리 | 16자리 | 24자리 |

&nbsp;

### 네트워크 주소와 브로드 캐스트 주소

- IP 주소
  - 네트워크 주소: 호스트 ID가 모두 10진수로 0인 주소
  - 브로드캐스트 주소: 호스트 ID가 모두 10진수로 255인 주소
    - 네트워크에 있는 모든 호스트로 데이터를 전달하는 방식

❗️네트워크 주소와 브로드 캐스트 주소는 IP주소로 할당 불가능  

### 서브넷

> **_A class와 같은 대규모 네트워크를 작은 네트워크로 분할하는 것을 '서브네팅'이라 하고, 분할된 각각의 네트워크를 서브넷이라 한다._**

- 그리고, IP 주소의 관점에서 보자면 호스트 ID의 일부를 서브넷 ID로 사용한다.  

### 서브넷 마스크

> **_네트워크 ID와 호스트 ID를 식별하기 위한 값_**

| 클래스 | 서브넷 마스크 10진수| 서브넷 마스크 2진수 | 프리픽스 |
| ---- | ---- |  ---- |
| A | 255.0.0.0 |11111111 00000000 00000000 00000000 |/8 |
| B | 255.255.0.0 | 11111111 11111111 00000000 00000000 |/16|
| c | 255.255.255.0 | 11111111 11111111 11111111 00000000 |/24|

🔆 프리픽스 표기법: 서브넷 마스크를 슬래시 비트 수로 나타낸 것으로, 네트워크 ID 부분을 나타낸다.

&nbsp;

### 라우터를 통한 스위치 간 흐름

host가 스위치에 데이터를 보내면 스위치는 라우터와 연결되어 있기 때문에, 같은 스위치 내의 host가 아니면 라우터로 데이터가 전달 -> 라우터는 수신처의 스위치로 데이터를 전달 -> 스위치가 받아서 해당되는 Host에 전달

각 Host의 기본 게이트웨이(default gateway)는 라우터의 연결된 IP 주소다.  

&nbsp;

---

# Reference

- [나노디그리 러닝스푼즈: Python & Django backend course](https://learningspoons.com/course/detail/django-backend/)
- [osi 7 layer](https://brunch.co.kr/@lars/1)
