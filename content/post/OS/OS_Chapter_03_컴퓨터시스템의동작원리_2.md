---
title: "[TIL] OS Chapter 03: 컴퓨터 시스템의 동작원리 2"
date: 2022-04-14T14:54:58+09:00
draft: false
summary: 입출력 구조, DMA, 저장장치의 구조 그리고 계층구조에 대해 알아본다. 또한, 하드웨어, 메모리, CPU의 각 보안 방법에 대해 알아본다.
tags: ["TIL", "OS"]
categories: ["OS"]
---

# 0. Introduction

- 해당 내용은 [운영체제와 정보기술의 원리 -반효경 지음-](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=) 와 [kocw 이화여자대학교 운영체제 - 반효경 교수 -](http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e)를 보고 정리한 내용입니다.
- 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.

<br>

---

# 5. 입출력 구조

- CPU의 명령 수행 속도는 빠르지만, 입출력 연산은 매우 느리다.
- 이 입출력 방식에는 **_동기식 입출력_** 과 **_비동기식 입출력_** 이 있다.

## 5.1 동기식 입출력(Synchronous I/O)

- 일반적으로 사용하는 방식으로 어떤 프로그램이 입출력했을 때, **_입출력 작업이 완료된 후에야_** 그 프로그램이 후속 작업을 수행할 수 있는 방식이다.

  - 예) 프로그램이 CPU를 점유한 상태에서 디스크에 정보를 읽어오라는 요청을 했다. 디스크 입출력이 완료되기까지 어느 정도의 시간이 소요된다. 이 때 **_동기식은 입출력 작업이 완료될 때까지 다음 명령을 수행하지 않고 기다린다_**. 그러다가 입출력이 완료되면 인터럽트를 통해 이 사실을 대기하고 있던 CPU에게 전달하고, CPU의 제어권이 프로그램에게 넘어가서 다음 명령을 수행할 수 있다.

- **_동기식 입출력 과정_**

  A process가 code 실행 중에 I/O 요청이 필요한 명령을 만나서 I/O 요청을 한다  
   → A는 CPU에게 system call이라는 SW interrupt를 발생  
   → CPU는 프로그램 A의 코드를 실행하던 일을 멈추고, 현재 상태를 프로그램의 PCB에 저장한다  
   → CPU의 제어권이 운영체제에게 넘어간다  
   → A가 입출력 연산을 요청했으므로, 운영체제가 프로세스 A를 봉쇄상태로 표시 그리고, 운영체제는 인터럽트 처리루틴 수행  
   → CPU는 컨트롤러에게 입출력 연산을 요청  
   → 컨트롤러는 A가 요청한 데이터를 디스크로부터 자신의 로컬 버퍼로 읽어온다.

  > **_A가 직접 입출력 작업을 하는 건 아니지만, A의 요청에 의해서 하는 것이므로, 이 과정을 프로세스 A가 입출력 작업을 수행 중이라 언급한다._**

  → 컨트롤러가 읽어오는 동안 CPU를 다른 프로그램 B에 할당해 계속 CPU가 일을 할 수 있도록 한다  
   → 원하는 정보가 로컬버퍼로 다 들어오면 컨트롤러는 CPU에게 입출력이 완료되었다는 사실을 인터럽트를 발생시켜 알린다. 이 때 발생시킨 인터럽트는 하드웨어 인터럽트다

  > **_프로세스 A가 입출력 작업을 완료했다고 언급한다._**

  → 프로그램 B를 수행 중이던 CPU는 수행하던 지점 및 상태를 process B의 PCB에 저장하고, 인터럽트를 처리  
   → 인터럽트 처리 루틴은 로컬 버퍼에 있는 A가 요청한 데이터를 A의 메모리 영역으로 읽어오고 A의 봉쇄 상태를 해제시킨다.  
   → A는 CPU를 기다리는 줄에 다시 선다  
   → 다시 B로 돌아와 업무를 중단한 지점부터 계속 진행  
   → A는 CPU를 큐에서 기다리다가 자신의 차례가 되면 CPU를 할당받고 입출력 연산 이후의 작업을 수행

<br>

### 5.1.1 입출력 연산 동안 CPU를 다른 process에게 할당하는 이유

- **_기본지식_**

  - 입출력 연산 속도는 CPU 연산 속도보다 매우 느리다.
  - 매 시점 시스템 내에서는 하나의 입출력만 수행할 수 있다. 하지만, 동기화는 자동적으로 이뤄진다.

- **_이유: CPU 낭비 방지를 위해서_**

  - _입출력 연산 속도는 매우 느려서 이를 수행하고 있는 프로그램이 CPU를 계속 점유하면, 프로그램의 입출력 연산이 끝날 때까지 CPU는 인터럽트를 기다리며 아무런 일을 하지 못한다. 그래서 일반적으로 프로그램이 입출력을 수행 중인 경우, CPU를 다른 프로그램에게 이양해 CPU가 쉬지 않고 일하도록 관리한다._

- **_입출력 작업을 수행 중인 프로세스에게 CPU를 할당해도 명령을 수행하지 못하는 이유_**
  - 입출력 중인 프로그램의 상태를 **_봉쇄 상태(Bblocked state)_** 로 전환하기 때문
  - 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU 할당 시 곧바로 명령을 수행할 수 있는 프로그램에만 CPU를 할당한다.
  - 인터럽트를 보내면 프로그램의 상태를 봉쇄 상태로부터 해제시킨다.

<br>

### 5.1.2 봉쇄 해제 후, ready 상태로 큐에서 기다리는 이유

- **_이유: 동기성 보장 = 동기화를 위해서_**

  - _입출력 수행 중일 때 다른 프로그램에게 CPU를 양도하면, 다수의 입출력 연산이 동시에 요청되거나 처리되어 동기화에 문제가 발생할 수 있다._
  - _그래서 입출력 요청의 동기화를 위해 장치별로 큐(queue)를 두어 요청한 순서대로 처리할 수 있도록 한다._

- **_예시_**

  - 프로그램 A가 먼저 요청했으면 이를 먼저 큐에 넣고, 그 후에 발생한 B의 요청을 A 요청 뒤에 삽입한다. 디스크 차원에서는 큐에 있는 순서대로 처리하여 동기화 문제를 해결할 수 있다.

<br>

### 5.1.3 Summary

- 동기식 입출력을 요청한 프로그램은 입출력이 완료될 때까지 다음 명령을 수행할 수 없어 CPU가 낭비된다.
- 그러나, CPU의 효율적인 사용을 위해 입출력이 수행하는 동안 다른 프로그램에게 CPU를 양도하면 동시에 다수의 입출력 연산이 일어날 수 있다.
- 그래서 다수의 프로그램이 동시에 입출력 연산을 요청하는 경우 동기성(synchronization)을 보장하기 위해 장치마다 큐를 두어 요청된 순서대로 처리할 수 있도록 한다.

<br>

## 5.2 비동기식 입출력(Asynchronous I/O)

- I/O가 시작된 후, 입출력 작업이 끝나기를 기다리지 않고 즉시 제어가 사용자 프로그램에 넘어간다.
- 그래서 입출력 연산과 무관한 처리 가능한 작업부터 처리한다.

<br>

---

# 6. DMA

> **_Direct Memory Access의 약어로, CPU의 중재 없이 device controller가 device의 buffer stroage에 읽어오면 CPU를 대신하여 잃어온 내용을 메모리에 block 단위로 직접 복사한 후, CPU에게 interrupt를 발생시키는 장치_**

- **_왜 DMA가 필요한가???_**
  - 문제점: CPU가 interrupt로 많은 방해를 받아 효율이 많이 떨어진다.
    - Interrupt가 발생하면 CPU는 controller의 local buffer와 memory 사이에서 데이터를 옮기는 일을 수행하는데, 만약 사용자 프로그램이 CPU를 사용하는 중에 I/O 장치가 interrupt를 많이 걸면, CPU가 많은 방해를 받아 CPU 효율이 많이 떨어진다.
  - 해결책: DMA가 CPU를 대신하여 local buffer에서 메모리로 읽어오는 작업을 수행한다.
    - CPU는 바이트(byte) 단위로 읽어오지만, DMA는 **byte가 아닌 block이라는 큰 단위로 정보를 메모리로 읽어온 후에** CPU에게 인터럽트를 발생시켜 해당 작업의 완료를 알리기 때문에, **인터럽트의 빈도를 줄인다.**
  - 결과: **_DMA를 통해 CPU를 효율적으로 관리하고, 입출력 연산을 빠르게 수행 가능_**

> **_메모리에는 CPU 뿐만 아니라 DMA도 접근할 수 있다는 걸 알 수 있다._**

<br>

---

# 7. 저장장치의 구조

- **_저장장치_** = 주기억장치 + 보조기억장치
- **_주기억장치_** = 메모리 = RAM with 휘발성(volatile)
- **_보조기억장치_** = 마그네틱 디스크 with 비휘발성(non-volatile)
  - ex) 마그네틱 디스크(하드디스크), 플래시 메모리, CD, 마그네틱 테이프
  - 보조기억장치의 용도 = file system용 + swap area용
    - file system용:
      - 비휘발성 성질을 이용하여 전원이 나가도 유지해야할 정보를 파일형태로 저장하는 용도
    - **swap area**용:
      - 메모리 한계로 메모리 연장 용도로 사용.
      - 프로그램 수행에 필요한 부분만 메모리에 올려놓고(process), 그렇지 않은 부분은 swap area에 내려놓는다.
      - swap area에 내려놓는 일을 **swap out(스왑 아웃)** 이라 한다.
      - 비휘발성으로 사용되는 file system용과 구분
- **_하드디스크의 물리적 구조_**
  - 여러 개의 **마그네틱 원판**들이 회전축에 붙어있고,
  - 원판의 표면은 **track**으로 나눠지고,
  - 각 track은 **sector**로 나눠지며, 이 sector에 **최소한의 단위 정보**가 저장된다.
  - Arm assembly에 연결된 arm이 움직이면서 head가 저장된 데이터를 읽고 쓴다.

<br>

---

# 8. 저장장치의 계층 구조

- 컴퓨터 시스템의 저장장치 계층 구조는 다음과 같다.
  - 위로 올라갈수록 속도는 빨라지고, 가격은 비싸지고, 용량은 적어진다.

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdPTp8O%2Fbtrp5zc8nw9%2FjmnWtXtTRsEsMEIexcbwy1%2Fimg.png)

- **_저장장치 = Primary(주기억장치) + Secondary(보조기억장치)_**
- **_Primary_**
  - 적은 용량, 빠른 속도, 비싼 가격
    - CPU는 한 clock 당 한 instruction이 걸리지만, Main memory는 10 clock 당 한 instruction이 걸린다. 그래서 그 중간의 완충으로 cache memory를 둔다.
  - 당장 필요한 정보를 저장
  - 구성: 휘발성 저장장치로 구성되어, 전원이 나가면 그 내용이 사라진다.
    - 최상위 CPU 내부에 존재하는 register부터 cache memory, main memory 등
    - regsiter: CPU 내부에 존재하는 작은 저장 장소
    - cache memory: CPU 내부에 있는 메모리로써, CPU와 main memory 간 속도 차이를 줄이기 위해 사용
- **_Secondary_**
  - 많은 용량, 느린 속도, 저렴한 가격
  - 당장 필요하지 않은 정보
  - 구성: 비휘발성 저장장치로 구성되어, 전원이 나가도 지워지지 않는다.
- **_Caching_**: copying information into faster storage system
  - 상대적으로 용량이 적은 빠른 저장장치를 이용해 느린 저장장치의 성능을 향상시키는 총체적인 기법
  - 상대적으로 ‘느린 저장장치’ 에 있는 내용 중 당장 필요한 것만 ‘빠른 저장장치’ 에 **_선별적으로 복사 저장_** 하여 두 저장장치의 속도를 완충시킨다.
  - 프로그램을 구성하는 모든 부분이 균일하게 사용되는 게 아니라, 일부분만 집중적으로 사용되기 때문에 적은 용량으로도 효과를 거둔다.

# 9. 하드웨어의 보안

- _하드웨어의 보안이 필요한 이유??_
  - OS는 multi-programming 환경에서 동작하기 때문에, 프로그램 간에 충돌이나, 다른 프로그램의 실행을 방해할 수 있기 때문.
- _Solution: 보조 장치 Mode bit 사용_
  - **Mode bit** 을 통해 하드웨어적으로 두 가지 모드의 **operation** 지원
  - _Mode bit == 0: kernel mode_
    - 운영체제가 CPU를 수행하는 mode
    - **모든 종류의 명령** 실행 가능
    - 보안을 해칠 수 있는 중요 명령어는 `특권명령` 으로 규정
    - 모든 I/O 명령은 `특권명령`이므로, kernel mode에서 실행
    - interrupt가 들어오면 mode bit는 0으로 setting
  - _Mode bit == 1: user mode_
    - 사용자 프로그램이 CPU를 수행하는 mode
    - 자신의 메모리 영역 주소만 보고 수행하여, 모든 기계어 실행을 막는다.
    - 사용자가 무한 루프로 CPU를 사용할 경우에도 timer가 있기 때문에 CPU 독점 사용 방지가능
    - 운영체제가 CPU 제어권을 사용자 프로그램에게 넘길 때 mode bit를 1로 세팅하여 넘긴다.
- _전환 mechanism_
  - CPU는 보안 관련 명령을 수행하기 전에는 항상 mode bit가 0인지 확인한다.
  - 입출력 명령도 보안 관련 명령이므로, 사용자 프로그램이 입출력을 직접 할 수 없고, 운영체제가 한다.
  - 그래서, 사용자 프로그램이 입출력을 하고 싶으면 sw interrupt인 system call을 CPU에 걸어서 운영체제가 CPU를 할당 받고, interrupt vector가 가리키는 위치를 통해 interrupt service routine으로 이동한다.
  - sw interrupt를 거는 순간 mode bit 는 1에서 0으로 세팅되어 입출력 명령을 수행할 수 있다.

![image](https://user-images.githubusercontent.com/78094972/163322482-5e78c22d-f94e-4022-9839-b6c826446b73.PNG)

<br>

---

# 10. 메모리 보안

- 메모리 보안이 필요한 이유??
  - 메모리에 여러 프로그램들이 동시에 올라와 실행되기 때문에, 한 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문이다.
  - 그래서 프로세스가 합법적인 메모리 범위에 있는지 체크하는 방법을 사용한다.
- **_Solution: 기준 레지스터(base register) + 한계 레지스터(limit register)_**
  - **기준 레지스터(base register)**
    - 어떤 프로그램이 수행하는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리 상의 가장 작은 주소를 보관한다.
  - **한계 레지스터(limit register)**
    - 프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관
- **_이 Solution을 어떻게 사용하는가???_**
  - 사용자 프로그램이 base register + limit register 값을 벗어나는 주소에 접근하면 **불법적인 메모리 접근이므로, SW interrupt인 exception을 발생**시킨다.
  - 그래서 CPU의 제어권을 해당 프로그램으로부터 운영체제로 이양시키고, 예외상황을 발생시킨 프로그램을 강제로 종료시킨다.
- 메모리 보안에서 특권명령
  - 기준 레지스터와 한계 레지스터의 **값을 세팅하는 연산**은 **특권명령**으로 규정.
  - **메모리 접근 연산**은 사용자 프로그램이 CPU를 가지고 있는 동안 수행되므로 특권명령이 아니다.
- kernel mode와 user mode의 메모리 접근 차이
  - kernel mode: 메모리에 무제한 접근 가능
  - user mode: base register와 limit register를 사용해서 메모리를 보호

![image](https://images.velog.io/images/jehjong/post/2393e5ae-7318-4b41-8879-da6d2cfc0df1/image.png)

<br>

---

# 11. CPU 보호

- CPU의 독점 사용을 방지하기 위해 **Timer(타이머) 라는 하드웨어**를 사용한다.
  - 사용자 프로그램이 CPU를 보유하고 있다가 정해진 시간이 흐른 뒤, 운영체제에게 제어권이 넘어가도록 interrupt를 발생시키는 하드웨어
  - 매 clock tick 때마다 1씩 감소하다가, 0이 되면 interrupt가 발생한다.
- timer의 값을 setting하는 명령을 **_load timer_** 라 하며, `특권 명령` 이다.
- timer는 시분할 시스템을 구현하기 위해서도 사용된다.

<br>

---

# 12. 시스템 콜을 이용한 입출력 수행

- 모든 입출력(I/O) 명령은 특권 명령(kernel 영역)에 해당한다.
- 그러면 사용자 프로그램은 어떻게 I/O를 하는가??
  - system call이라는 SW interrupt를 통하여 운영체제에게 I/O 서비스 대행 요청을 한다.
  - 그러면 제어권이 사용자 프로그램에서 운영체제로 넘어간다.
  - 그리고, 운영체제는 인터럽트 처리 루틴을 실행한다.
  - 입출력 완료 시, 제어권을 사용자 프로그램에게 넘긴다.

<br>

---

# Reference

- [운영체제와 정보기술의 원리](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=)
- [kocw 이화여자대학교 운영체제 - 반효경 교수 -](http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e)
