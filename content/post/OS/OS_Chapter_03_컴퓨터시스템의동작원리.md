---
title: "[TIL] Operating System Chapter 03: System Structure & Program Execution 1"
date: 2022-04-13T13:55:26+09:00
draft: false
summary: System Structure & Program Execution의 상편으로 한글 제목은 컴퓨터 시스템의 구조다. I/O 연산이 무엇이고, controller와 local buffer가 무엇이고, 입출력 연산이 Interrupt를 중심으로 어떻게 진행되는지를 알아본다.
tags: ["TIL", "python"]
categories: ["개발-dev OS"]
---

# 1. 컴퓨터 시스템의 구조

## 1.1 컴퓨터의 구조: 내부장치와 외부장치

컴퓨터 시스템의 구조는 크게 컴퓨터 내부장치와 외부장치로 나눠진다. **_컴퓨터 내부장치_** 에는 CPU, Memory가 존재하며, **_컴퓨터 외부장치_** 에는 Disk, keyboard, mouse, monitor, network device 등으로 존재한다.

## 1.2 컴퓨터의 업무 처리 방식

컴퓨터 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후, 연산 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다.

이때, 업무의 각 부분을 다음과 같이 정의한다.

- **_입력(input):_** 컴퓨터 내부로 데이터가 들어오는 것
- **_출력(output):_** 컴퓨터 외부장치로 데이터가 나가는 것
- 예시) **_입출력(Input-output: I/O)_**
  - 입출력: **_컴퓨터 시스템이 컴퓨터 외부 입출력 장치들과 데이터를 주고 받는 것_**
  - 키보드로부터 입력을 받아서 컴퓨터가 어떤 연산을 한 후, 그 결과를 모니터에 출력.
  - 컴퓨터 외부장치인 디스크에서 내용을 읽어 컴퓨터 내부에 연산을 한 후, 디스크에 데이터를 저장하기

## 1.3 Controller: 각 하드웨어 장치의 작은 CPU

컴퓨터 전체에 CPU(Cetnral Processing Unit)라는 중앙처리장치가 있듯이, 컴퓨터의 각 하드웨어 장치에는 이들을 제어하는 일종의 작은 CPU인 **_컨트롤러_** 가 있다. 예를 들어 메모리를 제어하는 컨트롤러는 메모리 컨트롤러, 디스크를 제어하는 컨트롤러는 디스크 컨트롤러다.

<br>

---

# 2. CPU 연산과 I/O 연산

## 2.1 연산 = CPU가 무언가를 한다

- 컴퓨터에서 **연산**을 한다는 건 **_CPU가 무언가 일을 한다_** 는 뜻이다.

- 컴퓨터의 구성장치 관점에서 연산을 나눠 보자면 다음과 같이 담당한다.

  - 입출력 장치들의 I/O 연산 → 입출력 컨트롤러가 담당
  - 컴퓨터 내에서 수행되는 연산 → main CPU
  - 이 때 입출력 장치와 main CPU는 일이 다른 곳에서 발생하므로 동시 수행이 가능하다.

## 2.2 Local Buffer(로컬 버퍼)

- 각 장치 컨트롤러에는 장치로부터 오고 가는 데이터를 **임시 저장** 하기 위한 작은 메모리인 **_로컬 버퍼(local buffer)_** 가 존재한다.
- 입력 장치로부터 데이터를 읽어오는 경우, 각 입력장치 컨트롤러가 장치에서 로컬버퍼로 데이터를 읽어와서 저장 후, 컴퓨터 내부 메모리에 전달한다.

## 2.3 CPU와 I/O 장치의 연산과정

1. 프로그램에서 데이터를 읽어오라는 명령을 내린다 →
2. 각 장치의 컨트롤러가 장치로부터 내용을 읽어 로컬버퍼에 저장한다 →
3. 데이터를 읽는 작업을 완료했기 때문에, 메인 CPU에서 다음 일을 수행이 가능하다. HW 또는 SW는 CPU 옆에 **_인터룹트 라인(interrup line)_** 을 세팅하는 명령을 실행하여, 컨트롤러가 **_인터룹트(interrupt)_** 를 발생시켜 메인 CPU에 완료를 알린다 →
4. CPU는 **_명령 하나를 수행할 때마다_** 인터룹트가 발생했는지 확인한다. →
5. 인터럽트가 발생하면 하던 일을 멈추고, **_인터럽트 처리를 먼저 한 후_** 명령을 다시 수행

<br>

---

# 3. 인터럽트의 일반적 기능

## 3.1 Interrupt(인터럽트)란??

- 인터럽트(Interrupt)란 **CPU의 제어권을 양도하라는 신호**를 말한다.
- 사용자 프로그램에게 CPU 제어권이 있어서, CPU를 사용하고 있다가 interrupt를 발생시키면 운영체제 코드 부분으로 CPU가 이양된다.
- 오늘날의 컴퓨터 운영체제는 인터럽트가 발생했을 때에만 실행된다.
  - 운영체제는 단지 인터럽트가 발생했을 때에만 CPU의 제어권을 획득할 수 있는데,
  - 인터럽트가 발생하지 않으면 실행 중인 사용자 프로그램이 계속 CPU를 점유한다.
  - **_운영체제가 CPU를 점유하는 경우는 인터럽트에 의하지 않고는 발생하지 않는다._**

## 3.2 인터럽트 처리루틴이란???

- 운영체제는 각종 하드웨어와 소프트웨어 자원 관리자(resource manager) 역할 뿐 아니라, 사용자 프로그램에 필요한 서비스도 제공한다.
- 그래서, 운영체제 개발자는 운영체제가 해야할 일들을 미리 프로그래밍 해서 커널 내에 보관돼 있다.
- 그 중 한가지가 **_인터룹트 처리루틴_** 이다.
- **인터럽트 처리루틴** 이란 **_다양한 인터럽트에 대해 각각 처리해야할 업무들을 정의한 것_**

- 인터럽트 처리루틴까지의 과정
  1. 컨트롤러가 인터럽트를 발생시키면 CPU는 인터럽트 라인을 통해 인터럽트 발생을 확인하고, 자신이 하던 일을 멈춘다.
  2. 프로그램의 실행 상태를 PCB에 저장한 후, CPU의 제어권은 프로세스에서 운영체제로 넘어간다.
  3. 그리고, 운영체제는 커널 내에 인터럽트 발생 시수행하도록 정의된 코드를 찾는다. 쉽게 찾기 위해서 운영체제는 **_인터럽트 벡터(interrupt vector)_** 를 가지고 있다.
     - 인터럽트 벡터란 **_인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키고 있는 자료구조_** 를 말한다.
  4. 이 interrupt vector가 가리키는 곳으로 가서 인터럽트 처리루틴을 찾는다.
     - 실제 처리해야할 코드는 **인터럽트 처리루틴(interrupt service routine)** 또는 **인터럽트 핸들러(interrupt handler)** 에 정의된다.
  5. 인터럽트 처리루틴을 통해 해당하는 인터럽트 처리를 완료하고 나면, CPU는 PCB로부터 CPU 상에 복원하여 인터럽트 당하기 직전의 위치부터 계속 수행한다.
     - 인터럽트 처리 후 돌아갈 위치를 알아야 하므로, 인터럽트 처리 전에 수행 중이던 작업이 무엇인지 반드시 저장한다.

## 3.3 인터럽트의 종류: HW interrupt 와 SW interrupt

인터럽트에는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다.

- HW interrupt와 SW interrupt의 공통점
  - CPU 옆 인터럽트 라인에 신호를 보내 인터럽트 발생유무를 알려주는 방식은 동일.
- HW interrupt와 SW interrupt의 차이점
  - HW interrupt
    - **하드웨어 장치**가 CPU의 interrupt line을 세팅한다.
    - 통상적으로 불리는 interrupt의 의미가 HW interrupt다.
  - SW interrupt
    - **소프트웨어**가 CPU의 interrupt line을 세팅한다.
    - SW interrupt는 **_트랩(trap)_** 이라는 용어로 주로 불린다.
    - Trap의 예: **_예외 상황(exception)_** 과 **_시스템 콜(system call)_**

## 3.3 SW interrupt: exception 과 system call

SW interrupt인 trap의 **_예외 상황(exception)_** 과 **_시스템 콜(system call)_** 에 대해 알아보자.

- 예외 상황(exception)
  - 비정상적인 작업을 시도하거나, 권한이 없는 작업을 시도할 때, 이에 대한 처리를 위해 발생시키는 인터럽트
    - 비정상적인 작업의 예: 사용자 프로그램이 0으로 나누는 연산을 실행
    - 권한이 없는 작업의 예: 프로그램이 자신의 메모리 영역 바깥에 접근하려는 시도
- 시스템 콜(system call)
  - **사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때**, 운영체제에 서비스를 요청하는 방법
  - 사용자 프로그램의 코드는 사용자 프로그램이 CPU에 대한 제어권을 가지고 실행한다.
  - 하지만, 커널 내부에 있는 코드를 사용자 프로그램이 실행하고자 할 때는 사용자 프로그램이 직접 접근할 수 있는 게 아니라, system call을 통해서 **_대행 요청_** 을 한다.
  - system call 요청을 interrupt line setting을 통해 CPU 제어권을 운영체제로 넘겨 커널 내부 코드를 실행한다.
  - 예) 애플리케이션 개발자가 프로그램 작성 중 키보드 입력이나, 화면 출력 등의 입출력 작업이 필요할 경우, 본인이 직접 입출력을 수행하는 코드를 작성하는 게 아닌, 이미 존재하는 커널의 코드를 호출해서 처리한다.

## 3.4 System call과 exception을 interrupt에 포함시킨 이유

system call과 exception 과정에서 프로그램 코드가 직접 interrupt line을 setting하는 명령을 실행하여, interrupt를 발생시킨 후, **_제어권이 운영체제에 넘어가므로_**, 넓은 의미에서는 interrupt 범주에 포함된다.

<br>

---

# 4. 인터럽트 핸들링(Interrupt handling)

## 4.1 Interrupt handling 이란??

- Interrupt handling이란 **_인터럽트가 발생한 경우에 처리해야할 일의 절차_** 를 말하는데, 구체적인 절차는 다음과 같다.
- 프로그램 A가 실행되고 있을 때, 인터럽트가 발생하면 **_프로그램 A의 현재 상태를 먼저 저장_** 한다.
  - 현재 상태란 현재 CPU에서 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보들을 의미한다.
- 현재 상태를 먼저 저장하는 이유는??
  - CPU에서 명령이 실행될 때 CPU 내부에 있는 임시 기억장치인 레지스터(register)에 데이터를 읽거나 쓰면서 작업을 한다.
  - 그런데, **_인터럽트가 발생해 새로운 명령을 실행하면 기존의 레지스터 값들이 지워지므로_** , CPU 내의 이러한 상태를 저장해둬야 한다.

## 4.2 PCB(Process Control Block)이란??

- OS가 현재 시스템 내에서 실행되는 프로그램들을 관리하기 위해 둔 자료구조를 **_PCB(Process Control Block, 프로세스 제어 블록)_** 라 한다.
- **_PCB_** 는
  - 각각의 **_프로그램마다 하나씩 존재_** 한다.
  - **_해당 프로그램의 어느 부분이 실행 중이었는지를 저장_** 한다.  
    ex) 코드의 메모리 주소, 레지스터값, 하드웨어 상태 등
- Interrupt 발생 → **_CPU의 제어권을 넘기기 전에 프로그램의 실행 상태를 PCB에 저장_**
  → CPU의 제어권이 OS로 넘어간다
  → 운영체제는 인터럽트 벡터가 가리키는 곳으로 가서 인터럽트 처리루틴에 따라 인터럽트 처리를 수행
  → 인터럽트 처리 완료 → 저장된 상태를 PCB로부터 CPU 상에 복원
  → 인터럽트 당하기 직전 위치부터 재실행

<br>

---

# 5. 입출력 구조

- 입출력이란 컴퓨터 시스템이 컴퓨터 외부 입출력 장치들과 데이터를 주고받는 것
- CPU의 명령 수행 속도는 빠르지만, 입출력 연산은 상대적으로 느리다.
- 이 입출력 방식에는 **_동기식 입출력_** 과 **_비동기식 입출력_** 이 있다.

## 5.1 동기식 입출력

- 일반적으로 사용하는 방식
- 어떤 프로그램이 입출력했을 때, **_입출력 작업이 완료된 후에야_** 그 프로그램이 후속 작업을 수행할 수 있는 방식이다.
  - 예) 프로그램이 CPU를 점유한 상태에서 디스크에 정보를 읽어오라는 요청을 했다. 디스크 입출력이 완료되기까지 어느 정도의 시간이 소요된다. 이 때 **_동기식은 입출력 작업이 완료될 때까지 다음 명령을 수행하지 않고 기다린다_**. 그러다가 입출력이 완료되면 인터럽트를 통해 이 사실을 대기하고 있던 CPU에게 전달하고, CPU의 제어권이 프로그램에게 넘어가서 다음 명령을 수행할 수 있다.
- **동기식 입출력 과정**

  - A process가 code 실행 중에 I/O 요청이 필요한 명령을 만나서 I/O 요청을 한다
    → A는 CPU에게 **_system call_** 이라는 SW interrupt를 발생  
     → CPU는 프로그램 A의 코드를 실행하던 일을 멈추고, 현재 상태를 프로그램의 PCB에 저장한다  
     → CPU의 제어권이 운영체제에게 넘어간다  
     → A가 입출력 연산을 요청했으므로, 운영체제가 프로세스 A를 봉쇄상태로 표시 + 운영체제는 인터럽트 처리루틴 수행  
     → CPU는 컨트롤러에게 입출력 연산을 요청  
     → 컨트롤러는 A가 요청한 데이터를 디스크로부터 자신의 로컬 버퍼로 읽어온다 + **컨트롤러가 읽어오는 동안 CPU를 다른 프로그램 B에 할당해 계속 CPU가 일을 할 수 있도록 한다**  
     → 원하는 정보가 로컬버퍼로 다 들어오면 컨트롤러는 CPU에게 입출력이 완료되었다는 사실을 인터럽트를 발생시켜 알린다. 이 때 발생시킨 인터럽트는 **_하드웨어 인터럽트_** 다  
     → 프로그램 B를 수행 중이던 CPU는 수행하던 지점 및 상태를 process B의 PCB에 저장하고, 인터럽트를 처리  
     → 인터럽트 처리 루틴은 로컬 버퍼에 있는 A가 요청한 데이터를 A의 메모리 영역으로 읽어오고 A의 봉쇄 상태를 해제시켜 A에게 CPU를 할당  
     → **A는 CPU를 기다리는 줄에 다시 선다.**  
     → 다시 B로 돌아와 업무를 계속 진행  
     → A는 CPU를 큐에서 기다리다가 자신의 차례가 되면 CPU를 할당받고 입출력 연산 이후의 작업을 수행

- **입출력 연산 동안 CPU를 다른 process에게 할당하는 이유**: **CPU 낭비 방지**

  - 기본 지식 1: 입출력 연산 속도는 CPU 연산 속도보다 매우 느리다.
  - 기본 지식 2: 매 시점 시스템 내에서는 하나의 입출력만 수행할 수 있다.
    - 하지만, 동기화는 자동적으로 이뤄진다.
  - _입출력 연산 속도는 매우 느려서 이를 수행하고 있는 프로그램이 CPU를 계속 점유하면, 프로그램의 입출력 연산이 끝날 때까지 CPU는 언터럽트를 기다리며 아무런 일을 하지 못한다._
  - _그래서 일반적으로 프로그램이 입출력을 수행 중인 경우, CPU를 다른 프로그램에게 이양해 CPU가 쉬지 않고 일하도록 관리한다._
  - **예시**  
    _프로세스 A가 CPU를 할당받고, 명령을 수행하다가 입출력 요청을 한다._  
    → 그러면 CPU를 다른 프로세스 B에게 할당한다.  
    → B가 CPU를 할당받아 명령을 수행하고, 프로세스 A는 입출력 작업을 수행한다.  
    → 프로세스 A가 입출력 작업을 완료할 때까지 CPU를 프로세스 A에게 할당 안한다.  
    → 또한, CPU를 프로세스 A에게 할당해도 명령을 수행하지 못하도록 봉쇄한다.  
    → 프로세스 A가 입출력 작업을 완료 후, 연산 완료의 통보로서 인터럽트를 보내야 CPU가 프로세스 A가 할당된다.

- **입출력 작업을 수행 중인 프로세스에게 CPU를 할당해도 명령을 수행하지 못하는 이유**

  - 입출력 중인 프로그램의 상태를 **_봉쇄 상태(Bblocked state)_** 로 전환하기 때문
  - 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU 할당 시 곧바로 명령을 수행할 수 있는 프로그램에만 CPU를 할당한다.
  - 인터럽트를 보내면 프로그램의 상태를 봉쇄 상태로부터 해제시킨다.

- **봉쇄 해제 후, ready 상태로 큐에서 기다리는 이유: 동기화**

  - _입출력 수행 중일 때 다른 프로그램에게 CPU를 양도하면, 다수의 입출력 연산이 동시에 요청되거나 처리되어 동기화에 문제가 발생할 수 있다._
  - _그래서 입출력 요청의 동기화를 위해 장치별로 큐(queue)를 두어 요청한 순서대로 처리할 수 있도록 한다._
  - **예시**
    - 프로그램 A가 먼저 요청했으면 이를 먼저 큐에 넣고, 그 후에 발생한 B의 요청을 A 요청 뒤에 삽입한다. 디스크 차원에서는 큐에 있는 순서대로 처리하여 동기화 문제를 해결할 수 있다.

### 5.1.3 Summary

- 동기식 입출력을 요청한 프로그램은 입출력이 완료될 때까지 다음 명령을 수행할 수 없기 때문에, CPU가 낭비된다.
- 그러나, CPU의 효율적인 사용을 위해 입출력이 수행하는 동안 다른 프로그램에게 CPU를 양도하면 동시에 다수의 입출력 연산이 일어날 수 있다.
- 그래서 다수의 프로그램이 동시에 입출력 연산을 요청하는 경우 동기성(synchronization)을 보장하기 위해 장치마다 큐를 두어 요청된 순서대로 처리할 수 있도록 한다.

<br>

---

## 5.2 비동기식 입출력

- 입출력 연산을 요청한 후, 연산이 끝나기를 기다리는 게 아닌 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하여, 입출력 연산과 무관한 처리 가능한 작업부터 처리
- CPU를 그 프로그램에게 다시 부여하여, 읽어온 결과를 이용해서 다음 연산을 하는 것과 관련 없는 일을 수행한다.
- 또는, 입출력 요청이 아닌 쓰는 요청이라면 완료되기 전에 다음 명령을 수행할 수 있다.
- 동기식과 마찬가지로 입출력 연산이 완료되면 인터럽트를 통해 CPU에게 알린다.

---

# Reference

- [운영체제와 정보기술의 원리](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=)
