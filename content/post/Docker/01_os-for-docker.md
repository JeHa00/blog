---
title: "Docker study: Docker 학습을 위한 OS background knowledge"
date: 2022-10-31T01:00:56+09:00
draft: false
summary: Docker 학습을 시작하기에 앞서 Docker가 왜 필요한지, 컴퓨터 시스템의 핵심은 무엇이고, 운영체제는 무슨 역할을 하는지, process와 thread란 무엇인지, 메모리 구조는 어떻게 구성되어 있는지, 마지막으로 컨테이너에 대해 체험해본다. 
tags: ["docker"]
categories: ["docker"]
---
# 0. Introduction


- 해당 강의는 [러닝스푼즈 - 나노디그리 Python & Django backed course](https://learningspoons.com/course/detail/django-backend/)의 장철원 강사님의 docker 강의를 학습한 내용입니다.

- docker는 운영체제와 많이 연관되어 있어서, docker를 잘 사용하고 한다면 운영체제에 대해 자세히 알아야 한다. 하지만, 많은 개발자들이 운영체제를 깊이 이해하지 못하여 docker를 잘 사용하지 못하는 상황이라고 한다.


<br>

---

# 1. 컴퓨터 시스템

서버의 용량이 가득찼을 때 할 수 있는 해결책 2가지: scale up & out

### 해결책 1: Scale up

- 장점: 더 고사양의 서버를 사용하여 1대로 운영가능
- 단점: 한번 먹통이 되면 서비스가 중단 가능성 있음

### 해결책 2: Scale out

- 수많은 서버에 프로그램을 배포하는 방식  
    - 서버를 1대에서 3대로 늘렸다고 생각을 했을 때, 3대에 배포를 다 해야한다.
- 문제점: 그러면 우리가 올리는 프로젝트가 다 제대로 올라갈 수 있을까? 그렇지 않다… 왜냐하면 사람의 컴퓨터 환경에 따라 다르기 때문이다.  
    - 10대 ~ 20대로 늘어나면 더 많은 어려움이 존재한다.
    - 그래서 어떻게 보면 운이 기대야하는 문제점이다. 


### 해결책 2 문제점의 해결책: docker

- docker를 사용하고 나서 위 문제점이 해결되었다. 

<br>

---

# 2. 좁은 의미의 컴퓨터

### 컴퓨터란?

- compute라는 어원이 시작된 것으로 computer 계산하는 기계를 의미한다.   
- 여기서 ‘계산’이란 우리가 생각하는 산수가 아닌 좀더 포괄적인 의미다.   

### 좁은 의미의 컴퓨터: CPU + RAM

컴퓨터를 열었을 때 main board에 있는 CPU와 RAM이 제일 중요하다.

- CPU
    - 계산을 담당하는게 CPU
    - CPU가 좋아질수록 처리속도가 그만큼 빠르다

- RAM
    - 노트에 수학문제에 대한 풀이를 적어놓는데, 이 풀이는 머리에서 처리한 결과를 잠깐 적어놓은 것이다.  
    - 그러면 왜 적어놓을까? 이를 기억하면서 풀 수 없기 때문이다. 
    - 내 두뇌를 이용해서 문제를 풀고 있지만 노트라는 보조장치를 이용해서 더 손쉬운 풀이를 가능하게 만들어준다.
    - RAM을 바로 이 용도로 생각하자.

- 보조장치
    - 좁은 의미의 컴퓨터는 CPU와 RAM을 합친거라고 보면 되고 나머지는 보조 장치라 할 수 있다.

- 입출력 장치
    - 키보드, 마우스, 모니터 

- 보조 기억 장치 (HDD, SSD)
    - RAM도 사실상 용량이 그렇게 크지 않기 때문에 보조 기억 장치를 사용

<br>

---

# 3. 운영체제 개념

컴퓨터는 하드웨어와 소프트웨어로 구성되어 있다. 그리고 이 소프트웨어는 User application과 OS로 구성되어 있다. 

- 하드웨어 : 마우스, 키보드 실제로 존재하는 컴퓨터를 구성하는 장치
- 소프트웨어 : 눈으로는 볼 수 있지만 손으로는 만질 수 없는 것들


이 OS를 또 쪼개면 kernel, OS 라이브러리, OS 외 라이브러리로 구성된다.  


### 전원이 켜지면?

전원이 켜지면 이 kernel이 보조기억장치에서 RAM으로 올라간다. 이 커널도 하나의 코드이고, 하드디스크에 존재한다.

컴퓨터 전원을 종료할 때까지 메모리에 올라가 있다. 

만약 이상한 에러가 있을 때 컴퓨터를 껏다키면 에러가 해결이 될 때가 있는데 커널이 메모리에 올라가있는 순간 발생한 문제들이 초기화됨

<br>

### shell이란?

> 커널과 사용자 간 다리 역할을 하는 프로그램으로, 이 shell을 사용하여 사용자는 운영체제와 상호작용이 가능하다.   

- 종류: bash, zsh  

<br>

### 운영체제의 기능

- 프로세서, 기억장치, 파일 정보 등 자원 관리
- 자원을 효율적으로 관리하기 위해 스케쥴링 기능 제공
    - 여러 명령어 중 무엇을 먼저 처리할 지 일정을 짜주는것
- 사용자와 시스템 간 편리한 인터페이스 제공
- 하드웨어와 네트워크 관리
- 프로그램이 실행될 수 있는 환경 제공

<br>

### 운영체제가 제공하는 서비스

- 프로그램 실행
    - 프로그램을 메모리에 올리고 실행 하는게 가능

- I/O 운영(operations)
    - 프로그램을 실행할 때는 파일이나 I/O 디바이스와 같은 I / O이 요구 될 수 있다.
    - 예를 들어 네트워크 인터페이스로부터 무언가를 읽는다거나 파일 시스템에 무언가를 쓸때 특정 디바이스의 특정 기능이 요구될 수 있다. 효율성을 위해 이는 유저가 직접 I/O 디바이스를 컨트롤 할 수는 없고, 이는 운영 체제가 담당한다.

- 파일 시스템
    - 프로그램은 파일이나 디렉토리를 읽거나 써야할 때가 있음
    - 파일이나 디렉토리의 이름을 짓거나 특정 파일을 검색할 때도 잇음

- 커뮤니케이션
    - 프로세스들끼리 정보를 교환해야하는 경우가 있는데 이처럼 프로세스들 간의 커뮤니케이션이나 네트워크를 이용해서 서로 다른 컴퓨터가 커뮤니케이션 해야할 경우가 있다. 이 경우 커뮤니케이션은 shared memory를 이용하는데 이때 shared memory에 데이터를 읽고 쓰는 일을 운영체제가 담당한다.

- resource allocation(할당)
    - 다수의 프로세스가 동시에 실행될 때 운영체제는 각 프로세스에 자원을 할당하는 역할을 한다.
    - 이때 자원이라는 것은 CPU, memory, storage같은 것을 의미한다.

<br>

---

# 4. Process와 Thread

### 프로그램(program)
> 프로그램이란? 실행 가능한 명령어의 집합

- 프로그램은 하드디스크와 같은 저장 장치에 저장되어 있지만 메모리에는 올라가지 않은 정적인 상태

- 프로그램은 메모리가 아닌 디스크에 존재한다.
    - 결론적으로 실행을 하지 않은 코드를 즉 프로그램이라고 한다.

- 컴파일된 바이너리 이미지 형태 or 파이썬 스크립트 같이 인터프리터 형태
    - 디스크에 저장된 실행 가능한 명령어의 집합이기만 하면 프로그램

<br>

### 컴파일러와 인터프리터

- 컴파일러(compiler)
    - 원시 코드 → 컴파일 언어 → 목적코드
    - 원시 코드를 목적 코드로 변환해주는 것
    - 실행속도는 빠르지만, 배우기는 어렵다
    - ex) C, JAVA


- 인터프리터(interpreter)
    - 한꺼번에 컴파일 단계를 거치는 컴파일 언어와 다르게 한줄 한줄 실행
    - 실행속도가 느리지만, 배우기는 빠르다


### Process
> **_실행 중인 프로그램_**  
> **_하드디스크에 있는 프로그램을 메모리(RAM) 상에 올린 것_**  

- 실상 프로그램을 여러개 사용했다라고 하는 건 프로그램이 아닌 프로세스를 여러개 돌리는 것이다.


그래서 프로세스를 너무 많이 사용하게 되면 더 이상의 프로그램(프로세스)를 띄울 수가 없다. 왜냐하면 RAM을 다 사용했기 때문이다.


### Thread

> **_프로세스가 할당 받은 자원을 이용하는 실행단위이자 프로세스 내에 실행되는 여러 흐름의 단위_** 

- 프로세스는 최소 한 개 이상의 쓰레드를 가짐, 이를 메인 쓰레드(main thread)라고 한다.

- 쓰레드는 독자적인 스택 메모리를 가진다.

- 프로세스는 쓰레드의 컨테이너이다. 프로세스는 쓰레드의 정보를 담고 있는 것에 불과하다.


- 쓰레드 예시(웹 브라우저의 경우)
    - 하나의 쓰레드는 이미지와 텍스트를 보여주는 일을 수행  
    - 다른 쓰레드는 네트워크 상의 데이터를 가져오는 일을 수행  



🔆 파이썬에서 멀티쓰레드가 존재하니까 여유가 생기면 공부해보자!

<br>

---

# 5. 메모리 구조

![image](https://user-images.githubusercontent.com/78094972/198869418-d2e97291-7129-4e2d-be51-0363abb4dd2f.png)

## Kernel space

- 우리가 컴퓨터를 실행하는 순간 커널 스페이스에 커널이 올라간다.
- 어떤걸 하더라고 커널 스페이스에는 프로세스를 못올린다.


## Process의 메모리 상에서 4가지 구조

- 메모리에 올라간 프로세스는 Stack - Heap - Data - Code 구조를 가진다. 
- Stack 방향으로 갈수록 높은 메모리 주소를 가지며, code 방향으로 갈수록 낮은 메모리 주소를 가진다. 

## 🔆 Stack

> **_지역변수, 매개변수, 함수 리턴값_**    
> **_- 위에서 아래로 쌓인다. (높은 메모리 주소 -> 낮은 메모리 주소 방향으로 할당)_**  

- 지역 변수(local variable) 저장
- 매개 변수(parameter) 저장  
- 함수 호출과 함께 할당  
- 함수 호출이 종료되면 소멸  
- 재귀 함수처럼 무한정 반복되는 함수 호출시 stack overflow 문제 발생
    - 해킹 시에는 일부러 stack overflow를 만들어서 들어간다. 


## 🔆 Heap

> **_동적 할당 데이터_**    
> **_stack과 반대방향으로 쌓인다. (낮은 메모리 주소 -> 높은 메모리 주소 방향으로 할당)_**    

- 사용자가 직접 관리하는 영역 
    - C언어에서는 사용자가 직접 입력하고, 지정하여 지정한 것만 사용한다. 그래서 지우는 것도 사용자가 직접 한다.  
    - 하지만 java에서는 java가 heap 할당을 해주기 때문에, garbage collector가 필요하다.  

- 사용자에 의해 메모리 할당 및 해제  
- C언어에서 malloc 명령어를 수행했을 때 메모리가 할당되는 곳  
- 자바에서 가비지 컬렉션을 할 때, 정리되는 영역  

## Data

> **_전역변수, 정적변수_**

- 전역변수 (global), 정적 변수(static)를 저장
- 프로세스 시작과 함께 할당
- 프로세스 종료와 함께 소멸  


## Code

> **_코드, 함수, 제어문_**

- 실행할 프로그램의 소스 코드가 저장되는 곳
- 그래서 텍스트(text) 영역이라고도 한다. 
- CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리한다.  
 

<br>

---
# 6. Namespace  

> **_프로세스를 실행할 때 시스템 리소스를 분리해서 실행할 수 있도록 도와주는 기능_**  

- 네임스페이스는 컨테이너 개념과 이어진다. 


### namespace의 종료와 역할

|네임스페이스 | 의미 | 역할|
| ---- |  ---- |  ---- |
|pid|PID: Process ID |리눅스 커널의 프로세스 ID 분리|
|net| NET: Networking |네트워크 인터페이스(NET) 관리|
|ipc| IPC: Inter Process Communication |프로세스 간 통신(IPC) 접근 관리|
|mnt| MNT: Mount | 파일 시스템의 마운트 관리|
|uts| UTX: Unix Timesharing System |커널과 버전 식별자 분리|


<br>

## 실습

- EC2 로그인 후, `work` directory를 생성한다. 그 안에 `test` directory 생성
- `ls -al` 또는 `ll` 입력하여 확인하기


### 프로그램 생성하기
- vim 으로 아무 파일 생성하기 ex) vi while_loop.py   


### 프로그램 실행하기
- `python while_loop.py &` 
    - `&`의 의미는 백그라운드 실행한다는 의미다. 그러면 다음과 같은 값이 뜬다. 
    -  `[1] 25514` 
    - 이는 **_PID_** 를 의미한다.  


- 다음으로 `ps -ef | grep while_loop`을 입력하면 다음과 같이 뜬다. 

```yml
#UID        PID    PPID   C STIME  TTY                      CMD  
ubuntu     25514   25390 99 10:14 pts/0    00:01:03 python3 while_loop.py
ubuntu     25522   25390  0 10:15 pts/0    00:00:00 grep --color=auto while_loop
```

### 프로그램을 담고 있는 컨테이너 확인하기

- 프로세스는 쓰레드를 담고 있는 컨테이너라고 했는데, 위 PID를 담고 있는 컨테이너를 확인해보자. 
    - `ls /proc`를 실행하면 여러 목록들이 나오는데 거기서 `25514`를 확인할 수 있다. 
    - `ls /proc/25514` 를 입력하면 여러 파일 목록들이 나온다. 
    - `/proc/25514`는 프로그램이 실행하는 동안 이 프로그램을 닫고 있는 컨테이너를 말한다. 

### 프로그램 종료 시키기  

- 만약 실행한 프로그램을 종료시키면 위에 생성된 `/proc/25514`는 사라진다.  
- 명령어: `kill -9 25514` 
- PID를 입력할 때는 복붙해서 한다.

```yml
ubuntu     25543   25390  0 10:25 pts/0    00:00:00 grep --color=auto while_loop
[1]+  Killed                  python3 while_loop.py
```

❗️ [root 계정이 아닌 사용자 추가하여 사용하기](https://losskatsu.github.io/os-kernel/aws-add-user/#aws-%EC%95%84%EB%A7%88%EC%A1%B4-%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%9C%A0%EC%A0%80-%EC%B6%94%EA%B0%80%ED%95%98%EA%B3%A0-password-%EC%A0%91%EC%86%8D-%ED%97%88%EC%9A%A9)


<br>

---


# Reference

- [러닝스푼즈 - 나노디그리 Python & Django backed course](https://learningspoons.com/course/detail/django-backend/)의 