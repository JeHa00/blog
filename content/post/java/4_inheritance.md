---
title: "상속과 오버라이딩이 메모리 영역에서 어떻게 이뤄지지?"
date: 2024-01-30T00:35:20+09:00
draft: true
summary: 자바에서는 상속과 오버라이딩을 어떻게 만드는지와 메모리 영역에서 어떻게 작동되는지 알아본다.  
tags: ["java"]
categories: "java"
---

# 상속에 대해서  

### 상속, 부모 클래스, 자식 클래스란?

**_기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하도록 물려받는 것을 '상속'이라 한다._** 

이 상속을 통해서 자신의 필드와 메서드를 제공하는 클래스를 **_부모 클래스 (슈퍼 클래스)_**, 부모 클래스로부터 필드와 메서드를 상속받는 클래스를 **_자식 클래스 (서브 클래스)_** 라 한다.  

자바에서 상속은 `extends` 라는 키워드를 통해서 수행된다. 이 키워드를 통한 상속은 오직 하나의 클래스만 받을 수 있다. '다중 상속'은 불가능하다. (하지만 이 부분을 해결하는 방법이 있다. 이는 나중에 학습하자.)

상속의 이점에 대해 알아보자.

아래에 상속을 받지 않는 `TomatoPasta` 와 `BaconCreamPasta`가 있다. 

- `TamatoPasta` 클래스
    
    ```java
    public class TomatoPasta {

        int price;
        String name;
        String sauce;

        public void cookTomato() {
            System.out.println("토마토를 조리합니다.");
        }

        public void complete() {
            System.out.println("조리를 완료합니다.");
        }

        public void serve() {
            System.out.println("완료된 음식을 서빙합니다.");
        }
    }
    ```



- `BaconCreamPasta` 클래스

    ```java
    public class BaconCreamPasta {
        
        int price;
        String name;
        String sauce;

        public void cookBacon() {
            System.out.println("베이컨을 조리합니다.");
        }

        public void makeCream() {
            System.out.println("크림 소스를 만듭니다.");
        }

        public void complete() {
            System.out.println("조리를 완료합니다.");
        }

        public void serve() {
            System.out.println("완료된 음식을 서빙합니다.");
        }
    }
    ```

위 2개의 클래스에 상속을 적용해보자.  

상속의 부모 클래스로 `Pasta` 를 만든다. `Pasta`를 한 이유는 토마토 파스타와 베이컨 크림 파스타 모두 파스타의 구체적인 개념이고, `Pasta`는 이 두 파스타의 추상적인 개념이기 때문이다.  

- `Pasta` 클래스

    ```java
    public class Pasta {

        int price;
        String name;
        String sauce;

        public void complete() {
            System.out.println("조리를 완료합니다.");
        }

        public void serve() {
            System.out.println("완료된 음식을 서빙합니다.");
        }
    }
    ```

- `TamatoPasta` 클래스

    ```java
    public class TomatoPasta extends Pasta {

        public void cookTomato() {
            System.out.println("토마토를 조리합니다.");
        }
    }
    ```

- `BaconCreamPasta` 클래스

    ```java
    public class BaconCreamPasta extends Pasta {

        public void cookBacon() {
            System.out.println("베이컨을 조리합니다.");
        }

        public void makeCream() {
            System.out.println("크림 소스를 만듭니다.");
        }
    }
    ```

모든 파스타에서 공통으로 가지는 속성과 기능은 `Pasta` 클래스에서 전달하고, 구체적인 파스타마다 가지는 필드와 기능은 자식 클래스에서 가진다.  

그래서 **_부모가 가지는 것은 상속을 통해 자식도 당연히 가지고 있지만, 자식이 가지고 있는 건 부모가 가질 수 없다._** 

&nbsp;

### 상속과 기능 추가  

그러면 상속의 장점을 느껴보자. 부모 클래스를 상속받은 자식 클래스 세 개가 있다. 

이 자식 클래스에 A라는 메서드와 B라는 필드를 추가할려고 할 때, 상속을 사용하지 않는다면 각 자식 클래스마다 A 메서드와, B 필드를 입력해야 한다. 하지만, '상속'을 사용한다면 자식 클래스가 상속 받은 부모 클래스에 추가한다면 손쉽게 확장할 수 있다.  

예시 코드를 통해 확인해보자. 앞선 예시와 동일한 코드에 속성과 기능을 하나씩 추가하려고 한다. 

- 속성: 면의 종류 정보를 가지고 있는 `noodle` 
- 기능: 면을 삶는 기능인 `cookNoodles()`

상속을 통해 `TomatoPasta`와 `BakonCreamPasta` 클래스에 각각 추가하지 않고 `Pasta` 클래스에 추가한다.  

- `Pasta` 클래스

    ```java
    public class Pasta {

        int price;
        String name;
        String sauce;
        String noodle;  // 추가된 속성

        // 추가된 기능
        public void cookNoodles() {
            System.out.println("면을 삶습니다.")
        }

        public void complete() {
            System.out.println("조리를 완료합니다.");
        }

        public void serve() {
            System.out.println("완료된 음식을 서빙합니다.");
        }
    }
    ```

나머지 `TomatoPasta`와 `BakonCreamPasta` 클래스들은 동일하다.  

만약 새로운 파스타 종류를 추가한다면 `Pasta`를 상속받아 새로 만드는 파스타만의 속성과 기능만 추가하면 된다.  

- 새로 추가하는 `GarlicAndOliveOilPasta` 클래스

    ```java
    public class GarlicAndOliveOilPasta extends Pasta {

        public void makeGarlicOilSauce() {
            System.out.println("마늘과 올리브 오일을 사용해서 소스를 만듭니다.");
        }
    }
    ```

&nbsp;

---


# 상속과 메모리 구조 🔆

우리는 앞선 포스팅에서 JVM의 메모리 영역에 대해서 학습했다. 

어떻게 메모리에서 상속이 어떻게 구현되고 작동되는지 알아보자.

위 예시 코드를 기반으로 각 파스타에 대한 인스턴스를 생성한 `PastaMain` 코드가 있다.

- `PastaMain` 클래스  

    ```java
    public class PastaMain {
        public static void main(String[] args) {
            TomatoPasta pasta1 = new TomatoPasta();

            pasta1.cookTomato();
            pasta1.complete();
        }
    }
    ```

그리고 `TomatoPasta` 만의 속성으로 `tomatoOrigin` 을 추가한다. 이 속성의 값은 `Korea`로 고정시킨다. 이러면 클래스 변수로 설정하는 게 좋지만, 상속과 메모리 구조 이해를 위해 한다.  

- `TomatoPasta` 클래스

    ```java
    public class TomatoPasta extends Pasta {

        String tomatoOrigin = "Korea";

        public void cookTomato() {
            System.out.println("토마토를 조리합니다.");
        }
    }
    ```

위 코드가 실행되면 다음 그림에 나온 순서처럼 실행된다.  

{{<figure src="https://github.com/JeHa00/image/assets/78094972/ed519615-4b16-4746-a835-0cf82a0a0c2a" width="90%">}}



### 인스턴스에는 부모와 자식 클래스 정보가 모두 포함되어 있고, 영역이 구분된다.  

**_인스턴스 참조값이 담겨진 참조 변수의 참조값은 하나이지만, 실제로 그 안에는 부모 클래스와 자식 클래스 정보가 공존한다. 즉, 부모 클래스까지 포함해서 인스턴스를 생성한다._** 그래서 상속이라고 하여 단순히 물려받는게 아니다. **_부모와 자식 클래스의 인스턴스 정보가 모두 생성되고 메모리 영역에서 공간도 구분된다._**  부모 클래스의 멤버 필드의 값 정보는 인스턴스의 부모 공간에 생성되고, 자식 클래스의 멤버 필드의 값 정보는 인스턴스의 자식 공간에 생성된다.

- 위 내용을 바탕으로 다시 위 그림을 보자. `pasta1` 참조 변수가 `TomatoPasta` 클래스의 인스턴스 참조값을 가지고 있다. 이 참조값이 가리키고 있는 heap 영역을 보면 생성된 인스턴스 내부에는 부모 클래스인 `Pasta`의 영역과 자식 클래스인 `TomatoPasta`의 영역으로 나눠져 있는 걸 확인할 수 있다. 그래서 단지 `TomatoPasta`의 인스턴스 속성만 있는 게 아니라, `Pasta`의 인스턴스 속성도 있는 걸 확인할 수 있다. 

### 메모리 공간 크기

그래서 메모리 공간 크기의 관점에서 보자면 부모 클래스의 필드와 속성까지 생성되기 때문에 메모리 공간이 더 필요하다.    

- 위 내용을 바탕으로 다시 위 그림을 보면 왜 메모리 공간 크기가 더 필요한지 직관적으로 받아들여질 수 있다.  

### 상속 관계 객체 호출 시, 대상 타입 지정

**_인스턴스 내부에 부모 클래스 속성까지 포함해서 생성되기 때문에, 참조 변수 선언 시 어떤 객체 타입으로 할지를 정확하게 지정해줘야 한다._** 왜냐하면 인스턴스에는 부모 클래스에 대한 정보와 자식 클래스에 대한 정보가 모두 포함되어 있기 때문에, 어느 클래스부터 조회할지를 결정해야 한다. 이를 결정하는 방법이 바로 호출하는 변수의 타입(클래스)을 기준으로 선택하기 때문이다.

- 위 내용을 바탕으로 그림을 다시 보면 참조 변수 `pasta1`을 선언할 때 `TomatoPasta`로 타입을 지정했기 때문에 메서드 실행 시, 첫 번째로 조회하는 클래스 타입이 `TomatoPasta`임을 알 수 있다.  


### 참조 방향

지정한 본인 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. **_만약 더 더 상위 부모 타입까지 찾았는데 찾지 못한다면 컴파일 오류가 발생한다. 왜냐하면 참조 방향이 아래에서 위로만 올라가기 때문이다._**  

처음에는 본인 타입에서 필요한 필드나 메서드를 찾는다. 없으면 부모 타입에서 찾는다. 이렇게 계속 더 상위 부모에서 필요한 정보를 찾는다.   

- 위 내용을 바탕으로 그림을 다시 보면 `pasta1.complete()`를 실행할 때 `TomatoPasta` 클래스에서 찾지 못하자 `extends` 예약어를 통해서 부모 클래스를 인식하여 `Pasta` 부모 클래스로 올라가 `complete()` 메서드를 실행한 걸 확인할 수 있다. 

그러면 위 코드를 수정해서 컴파일 오류를 발생시켜보자. 

```java
    public class PastaMain {
        public static void main(String[] args) {
            Pasta pasta1 = new TomatoPasta();

            pasta1.cookTomato();
        }
    }
```

위와 같이 수정했다. 인스턴스는 `TomatoPasta`의 인스턴스이기 때문에 인스턴스에는 부모 클래스와 자식 클래스의 인스턴스 속성 정보가 모두 포함되어 있다. 참조 방향이 위에서 아래로 올라간다면 위 코드는 컴파일 에러가 발생되고, 방향 상관없이 찾는다면 에러가 발생되지 않는다. 

다음과 같은 컴파일 에러가 발생했다.

```
java: cannot find symbol
  symbol:   method cookTomato()
```

위 결과를 통해서 **_참조 방향은 반드시 아래에서 위로만 올라간다_** 는 걸 확인했다.  

&nbsp;

---
# 오버라이딩  


### @override 애노테이션이 필요한 이유  

`@` 이 붙은 부분을 애노테이션이라 한다. 애노테이션은 주석과 비슷한데, 프로그램이 읽을 수 있는 특별한 주석이라 생각
하면 된다. 애노테이션에 대한 자세한 내용은 따로 설명한다.
이 애노테이션은 상위 클래스의 메서드를 오버라이드하는 것임을 나타낸다.

이름 그대로 오버라이딩한 메서드 위에 이 애노테이션을 붙여야 한다.
컴파일러는 이 애노테이션을 보고 메서드가 정확히 오버라이드 되었는지 확인한다. 오버라이딩 조건을 만족시키지 않으 면 컴파일 에러를 발생시킨다. 따라서 실수로 오버라이딩을 못하는 경우를 방지해준다. 예를 들어서 이 경우에 만약 부 모에 `move()` 메서드가 없다면 컴파일 오류가 발생한다. 참고로 이 기능은 필수는 아니지만 코드의 명확성을 위해 붙 여주는 것이 좋다.


자식의 오버라이딩한 메서드를 호출하고 싶은데 이 메서드 이름에 오타나 파라미터에 문제가 생겨서 이 메서드가 아닌 
자식에서 정보를 찾지 못해 부모의 메서드를 호출하는 경우가 있다.  ex) movee
이 경우를 막고자 필요하다. 부모의 메서드를 오버라이딩한 메서드임을 알려주어 이게 어긋날 경우 컴파일 에러를 발생시키는 예약어가 @Override다. 없어도 오버라이딩은 되지만, 없으면 에러를 잡아내지 못한다. 그러니 ‘관례’ 및 ‘권장’이어도 반드시 하자.


<예시 코드>

&nbsp;

### 오버로딩(Overloading)과 오버라이딩(Overriding)

메서드 오버로딩**: 메서드 이름이 같고 매개변수(파라미터)가 다른 메서드를 여러개 정의하는 것을 메서드 오버로딩(Overloading)이라 한다. 오버로딩은 번역하면 과적인데, 과하게 물건을 담았다는 뜻이다. 따라서 같은 이름 의 메서드를 여러개 정의했다고 이해하면 된다.
**메서드 오버라이딩**: 메서드 오버라이딩은 하위 클래스에서 상위 클래스의 메서드를 재정의하는 과정을 의미한다. 따라서 상속 관계에서 사용한다. 부모의 기능을 자식이 다시 정의하는 것이다. 오버라이딩을 단순히 해석하면 무 언가를 넘어서 타는 것을 말한다. 자식의 새로운 기능이 부모의 기존 기능을 넘어 타서 기존 기능을 새로운 기능으 로 덮어버린다고 이해하면 된다. 오버라이딩을 우리말로 번역하면 무언가를 다시 정의한다고 해서 **재정의**라 한다. 상속 관계에서는 기존 기능을 다시 정의한다고 이해하면 된다. 실무에서는 메서드 오버라이딩, 메서드 재정의 둘 다 사용한다.

&nbsp;

### 오버라이딩의 조건

메서드 시그니처 = 메서드 이름 + 파라미터의 타입, 순서, 갯수

메서드 오버라이딩은 다음과 같은 까다로운 조건을 가지고 있다.
다음 내용은 아직 학습하지 않은 내용들도 있으므로 모두 이해하려고 하기 보다는 참고만 하자. 지금은 단순히 **부모 메서드와 같은 메서드를 오버라이딩 할 수 있다 정도로 이해하면 충분한다.**
**메서드 오버라이딩 조건**
**메서드 이름**: 메서드 이름이 같아야 한다.
**메서드 매개변수(파라미터)**: 매개변수(파라미터) 타입, 순서, 개수가 같아야 한다.
**반환 타입**: **반환 타입이 같아야 한다**. 단 반환 타입이 하위 클래스 타입일 수 있다.
**접근 제어자**: 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적이어서는 안된다. 예를 들 어, 상위 클래스의 메서드가 `protected` 로 선언되어 있으면 하위 클래스에서 이를 `public` 또는
`protected` 로 오버라이드할 수 있지만, `private` 또는 `default` 로 오버라이드 할 수 없다.
**예외**: 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 `throws` 로 선언할 수 없다. 하지만 더 적거나 같은 수의 예외, 또는 하위 타입의 예외는 선언할 수 있다. 예외를 학습해야 이해할 수 있다. 예외는 뒤 에서 다룬다.
`static` , `final` , `private` : 키워드가 붙은 메서드는 오버라이딩 될 수 없다.
`static` 은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없다. 쉽게 이 야기해서 그냥 클래스 이름을 통해 필요한 곳에 직접 접근하면 된다.
`final` 메서드는 재정의를 금지한다.
`private` 메서드는 해당 클래스에서만 접근 가능하기 때문에 하위 클래스에서 보이지 않는다. 따라서 오 버라이딩 할 수 없다.
**생성자 오버라이딩**: 생성자는 오버라이딩 할 수 없다.


&nbsp;

---

# super

### 부모 참조

부모와 자식의 필드명이 같거나 메서드가 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드를 호출할 수 없다.
이때 `super` 키워드를 사용하면 부모를 참조할 수 있다. `super` 는 이름 그대로 부모 클래스에 대한 참조를 나타낸다.
다음 예를 보자. 부모의 필드명과 자식의 필드명이 둘다 `value` 로 똑같다. 메서드도 `hello()` 로 자식에서 오버라이 딩 되어 있다. 이때 자식 클래스에서 부모 클래스의 `value` 와 `hello()` 를 호출하고 싶다면 `super` 키워드를 사용하 면 된다.

&nbsp;

### 생성자  

상속 관계의 인스턴스를 생성하면 결국 메모리 내부에는 자식과 부모 클래스가 각각 다 만들어진다. `Child` 를 만들면
부모인 `Parent` 까지 함께 만들어지는 것이다. 따라서 각각의 생성자도 모두 호출되어야 한다.
**상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.(규칙)**
상속 관계에서 부모의 생성자를 호출할 때는 `super(...)` 를 사용하면 된다. 예제를 통해 상속 관계에서 생성자를 어떻게 사용하는지 알아보자.

`ClassB` 는 `ClassA` 를 상속 받았다. 상속을 받으면 **생성자의 첫줄**에 `super(...)` 를 사용해서 부모 클래스의 생성자를 호출해야 한다.
예외로 생성자 첫줄에 `this(...)` 를 사용할 수는 있다. 하지만 `super(...)` 는 자식의 생성자 안에서
언젠가는 반드시 호출해야 한다.
부모 클래스의 생성자가 기본 생성자(파라미터가 없는 생성자)인 경우에는 `super()` 를 생략할 수 있다.
상속 관계에서 첫줄에 `super(...)` 를 생략하면 자바는 부모의 기본 생성자를 호출하는 `super()` 를 자 동으로 만들어준다.
참고로 기본 생성자를 많이 사용하기 때문에 편의상 이런 기능을 제공한다.


<예시 코드>



<호출 그림>

this와 함께 사용  

&nbsp;

---



# 상속과 접근 제어  


&nbsp;

---